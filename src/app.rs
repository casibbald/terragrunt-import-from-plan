//! # Application Input File Loading Module
//! 
//! This module handles loading and parsing of input files used by the terragrunt import tool.
//! It provides functions for loading Terraform plan files and Terragrunt modules files,
//! with proper error handling and context information.
//! 
//! ## Supported File Types
//! 
//! - **Modules File** (`modules.json`): Generated by terragrunt, contains module metadata
//! - **Plan File** (`.json`): Generated by terraform plan with `-out` and converted to JSON
//! 
//! ## Error Handling
//! 
//! All functions use `anyhow::Result` for comprehensive error reporting with context.
//! Errors include file path information to help with debugging.

use crate::importer::{ModulesFile, PlanFile};
use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

/// Loads and parses the modules file from the given path
/// 
/// The modules file is typically named `modules.json` and is generated by terragrunt.
/// It contains metadata about all modules in the workspace, including their source
/// paths and directory locations.
/// 
/// # Arguments
/// * `path` - Path to the modules.json file
/// 
/// # Returns
/// Parsed ModulesFile structure containing module metadata
/// 
/// # Errors
/// - File not found or not readable
/// - Invalid JSON format
/// - JSON doesn't match expected ModulesFile structure
/// 
/// # Example
/// ```no_run
/// use terragrunt_import_from_plan::app::load_modules;
/// 
/// let modules = load_modules("path/to/modules.json")?;
/// println!("Found {} modules", modules.modules.len());
/// ```
pub fn load_modules<P: AsRef<Path>>(path: P) -> Result<ModulesFile> {
    let path = path.as_ref();
    let content = fs::read_to_string(path)
        .with_context(|| format!("Failed to read modules file: {}", path.display()))?;
    
    let modules: ModulesFile = serde_json::from_str(&content)
        .with_context(|| format!("Failed to parse modules JSON in file: {}", path.display()))?;
    
    Ok(modules)
}

/// Loads and parses the plan file from the given path
/// 
/// The plan file should be a JSON representation of a Terraform plan, typically
/// generated using `terraform plan -out=plan.tfplan` followed by 
/// `terraform show -json plan.tfplan > plan.json`.
/// 
/// # Arguments
/// * `path` - Path to the plan JSON file
/// 
/// # Returns
/// Parsed PlanFile structure containing planned resources and provider schemas
/// 
/// # Errors
/// - File not found or not readable
/// - Invalid JSON format
/// - JSON doesn't match expected PlanFile structure
/// 
/// # Example
/// ```no_run
/// use terragrunt_import_from_plan::app::load_plan;
/// 
/// let plan = load_plan("path/to/plan.json")?;
/// println!("Plan format version: {}", plan.format_version);
/// ```
pub fn load_plan<P: AsRef<Path>>(path: P) -> Result<PlanFile> {
    let path = path.as_ref();
    let content = fs::read_to_string(path)
        .with_context(|| format!("Failed to read plan file: {}", path.display()))?;
    
    let plan: PlanFile = serde_json::from_str(&content)
        .with_context(|| format!("Failed to parse plan JSON in file: {}", path.display()))?;
    
    Ok(plan)
}

/// Loads both modules and plan files with proper error context
/// 
/// This is a convenience function that loads both required input files for the
/// import process. It provides better error context by indicating which file
/// failed to load.
/// 
/// # Arguments
/// * `modules_path` - Path to the modules.json file
/// * `plan_path` - Path to the plan JSON file
/// 
/// # Returns
/// Tuple of (ModulesFile, PlanFile) ready for import processing
/// 
/// # Errors
/// - Either file not found or not readable
/// - Invalid JSON format in either file
/// - JSON doesn't match expected structure
/// 
/// # Example
/// ```no_run
/// use terragrunt_import_from_plan::app::load_input_files;
/// 
/// let (modules, plan) = load_input_files("modules.json", "plan.json")?;
/// println!("Loaded {} modules and plan version {}", 
///          modules.modules.len(), plan.format_version);
/// ```
pub fn load_input_files<P1: AsRef<Path>, P2: AsRef<Path>>(
    modules_path: P1, 
    plan_path: P2
) -> Result<(ModulesFile, PlanFile)> {
    let modules = load_modules(modules_path)
        .context("Failed to load modules file")?;
    
    let plan = load_plan(plan_path)
        .context("Failed to load plan file")?;
    
    Ok((modules, plan))
}

/// Unit tests for file loading functionality
/// 
/// These tests verify proper loading of modules and plan files, as well as
/// error handling for various failure scenarios using temporary files.
#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    /// **TEST** - Verifies successful loading of a valid modules file
    /// 
    /// Creates a temporary file with valid modules JSON and verifies that
    /// the parsing succeeds and returns the expected data structure.
    #[test]
    fn test_load_modules_success() {
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(
            temp_file,
            r#"{{"Modules": [{{"Key": "test", "Source": "./test", "Dir": "test"}}]}}"#
        ).unwrap();
        
        let result = load_modules(temp_file.path());
        assert!(result.is_ok());
        
        let modules = result.unwrap();
        assert_eq!(modules.modules.len(), 1);
        assert_eq!(modules.modules[0].key, "test");
    }

    /// **TEST** - Verifies error handling for non-existent modules file
    /// 
    /// Tests that attempting to load a non-existent file returns an appropriate
    /// error with context information about the missing file.
    #[test]
    fn test_load_modules_file_not_found() {
        let result = load_modules("/nonexistent/path/modules.json");
        assert!(result.is_err());
        let error_string = result.unwrap_err().to_string();
        assert!(error_string.contains("Failed to read modules file"));
    }

    /// **TEST** - Verifies error handling for invalid modules JSON
    /// 
    /// Tests that attempting to parse invalid JSON returns an appropriate
    /// error with context about the JSON parsing failure.
    #[test]
    fn test_load_modules_invalid_json() {
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "invalid json").unwrap();
        
        let result = load_modules(temp_file.path());
        assert!(result.is_err());
        let error_string = result.unwrap_err().to_string();
        assert!(error_string.contains("Failed to parse modules JSON"));
    }

    /// **TEST** - Verifies successful loading of a valid plan file
    /// 
    /// Creates a temporary file with valid plan JSON and verifies that
    /// the parsing succeeds and returns the expected data structure.
    #[test]
    fn test_load_plan_success() {
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(
            temp_file,
            r#"{{"format_version": "1.0", "terraform_version": "1.0", "variables": null, "planned_values": null, "provider_schemas": null}}"#
        ).unwrap();
        
        let result = load_plan(temp_file.path());
        assert!(result.is_ok());
        
        let plan = result.unwrap();
        assert_eq!(plan.format_version, "1.0");
    }

    /// **TEST** - Verifies error handling for non-existent plan file
    /// 
    /// Tests that attempting to load a non-existent plan file returns an
    /// appropriate error with context information.
    #[test]
    fn test_load_plan_file_not_found() {
        let result = load_plan("/nonexistent/path/plan.json");
        assert!(result.is_err());
        let error_string = result.unwrap_err().to_string();
        assert!(error_string.contains("Failed to read plan file"));
    }

    /// **TEST** - Verifies error handling for invalid plan JSON
    /// 
    /// Tests that attempting to parse invalid JSON in a plan file returns
    /// an appropriate error with context about the parsing failure.
    #[test]
    fn test_load_plan_invalid_json() {
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "invalid json").unwrap();
        
        let result = load_plan(temp_file.path());
        assert!(result.is_err());
        let error_string = result.unwrap_err().to_string();
        assert!(error_string.contains("Failed to parse plan JSON"));
    }

    /// **TEST** - Verifies successful loading of both input files
    /// 
    /// Tests the convenience function that loads both modules and plan files
    /// simultaneously, ensuring both are parsed correctly.
    #[test]
    fn test_load_input_files_success() {
        let mut modules_file = NamedTempFile::new().unwrap();
        writeln!(
            modules_file,
            r#"{{"Modules": [{{"Key": "test", "Source": "./test", "Dir": "test"}}]}}"#
        ).unwrap();
        
        let mut plan_file = NamedTempFile::new().unwrap();
        writeln!(
            plan_file,
            r#"{{"format_version": "1.0", "terraform_version": "1.0", "variables": null, "planned_values": null, "provider_schemas": null}}"#
        ).unwrap();
        
        let result = load_input_files(modules_file.path(), plan_file.path());
        assert!(result.is_ok());
        
        let (modules, plan) = result.unwrap();
        assert_eq!(modules.modules.len(), 1);
        assert_eq!(plan.format_version, "1.0");
    }

    /// **TEST** - Verifies error propagation when modules file fails to load
    /// 
    /// Tests that when the modules file fails to load, the error is properly
    /// propagated with appropriate context information.
    #[test]
    fn test_load_input_files_modules_fail() {
        let mut plan_file = NamedTempFile::new().unwrap();
        writeln!(
            plan_file,
            r#"{{"format_version": "1.0", "terraform_version": "1.0", "variables": null, "planned_values": null, "provider_schemas": null}}"#
        ).unwrap();
        
        let result = load_input_files("/nonexistent/modules.json", plan_file.path());
        assert!(result.is_err());
        let error_string = result.unwrap_err().to_string();
        assert!(error_string.contains("Failed to load modules file"));
    }
} 