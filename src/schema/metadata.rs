//! # Schema Metadata Processing Module
//! 
//! This module provides functionality for extracting and processing metadata from terraform
//! provider schemas. It converts raw JSON schema definitions into structured metadata that
//! can be used for intelligent ID scoring and resource analysis.
//! 
//! ## Key Components
//! 
//! - **AttributeMetadata**: Rich metadata about terraform resource attributes
//! - **Schema Parsing**: Extract metadata from terraform provider schema JSON
//! - **ID Scoring Integration**: Calculate base scores for ID candidate selection
//! - **Validation Logic**: Determine which attributes could be viable ID fields
//! 
//! ## Usage Patterns
//! 
//! 1. Parse schema JSON using `AttributeMetadata::from_schema_value()`
//! 2. Use metadata for intelligent scoring in provider strategies
//! 3. Validate ID candidates using `is_potential_id()`
//! 4. Calculate base scores using `calculate_base_score()`
//! 
//! ## Integration
//! 
//! This module integrates closely with the scoring strategies to provide schema-driven
//! intelligence for ID inference, replacing hardcoded rules with dynamic analysis.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Rich metadata about a terraform resource attribute extracted from provider schema
/// 
/// This structure contains comprehensive information about a terraform resource attribute,
/// including its constraints, type information, and descriptive metadata. It enables
/// intelligent analysis for ID candidate selection and resource understanding.
/// 
/// # Key Features
/// - **Constraint Analysis**: Required, computed, optional field detection
/// - **Type Information**: Attribute type classification (string, number, bool, etc.)
/// - **Documentation**: Human-readable descriptions and formatting information
/// - **Security**: Sensitive field detection for proper handling
/// - **ID Scoring**: Built-in scoring logic for ID candidate evaluation
/// 
/// # Fields
/// - `required`: Indicates if the attribute is required when creating the resource
/// - `computed`: Indicates if the attribute is auto-generated by the provider
/// - `optional`: Indicates if the attribute can be omitted
/// - `attr_type`: The terraform type of the attribute (string, number, bool, etc.)
/// - `description`: Human-readable description of the attribute's purpose
/// - `description_kind`: Format of the description (plain text, markdown, etc.)
/// - `sensitive`: Whether the attribute contains sensitive information
/// 
/// # Examples
/// ```no_run
/// use terragrunt_import_from_plan::schema::metadata::AttributeMetadata;
/// use serde_json::json;
/// 
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let schema = json!({
///     "type": "string",
///     "description": "The unique identifier for the resource",
///     "required": true,
///     "computed": false
/// });
/// 
/// let metadata = AttributeMetadata::from_schema_value(&schema)?;
/// println!("Base score: {}", metadata.calculate_base_score());
/// println!("Potential ID: {}", metadata.is_potential_id());
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AttributeMetadata {
    /// Whether this attribute is required when creating the resource
    /// 
    /// Required attributes are essential for resource creation and are often
    /// key identifying information. They receive higher ID candidate scores.
    pub required: bool,

    /// Whether this attribute is computed (auto-generated) by the provider
    /// 
    /// Computed attributes are generated by the cloud provider and often
    /// contain auto-generated IDs, ARNs, or other identifying information.
    pub computed: bool,

    /// Whether this attribute is optional (can be omitted)
    /// 
    /// Optional attributes can be provided but aren't required. They may
    /// still be useful for identification in some cases.
    pub optional: bool,

    /// The type of the attribute ("string", "number", "bool", "list", "map", etc.)
    pub attr_type: String,

    /// Human-readable description of the attribute
    pub description: Option<String>,

    /// The kind of description ("plain", "markdown")
    pub description_kind: Option<String>,

    /// Whether this attribute is sensitive (contains secrets)
    pub sensitive: Option<bool>,
}

impl AttributeMetadata {
    /// Creates a new AttributeMetadata instance from terraform schema JSON
    /// 
    /// This method parses the raw JSON schema definition for a terraform attribute
    /// and extracts all relevant metadata into a structured format. It handles
    /// missing fields gracefully by providing sensible defaults.
    /// 
    /// # Arguments
    /// * `value` - JSON value containing the terraform schema definition for an attribute
    /// 
    /// # Returns
    /// Result containing the parsed AttributeMetadata or an error if parsing fails
    /// 
    /// # Schema Format
    /// The expected JSON schema follows terraform's provider schema format:
    /// ```json
    /// {
    ///   "type": "string",
    ///   "description": "Human readable description",
    ///   "required": true,
    ///   "computed": false,
    ///   "optional": false,
    ///   "sensitive": false
    /// }
    /// ```
    /// 
    /// # Error Handling
    /// - Missing fields are handled with sensible defaults (false for booleans, "unknown" for type)
    /// - Invalid JSON structure returns AttributeMetadataError
    /// - Type mismatches are handled gracefully where possible
    /// 
    /// # Examples
/// ```no_run
/// use terragrunt_import_from_plan::schema::metadata::AttributeMetadata;
/// use serde_json::json;
/// 
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let schema = json!({
///     "type": "string",
///     "description": "The resource name",
///     "required": true,
///     "computed": false
/// });
/// 
/// let metadata = AttributeMetadata::from_schema_value(&schema)?;
/// assert_eq!(metadata.attr_type, "string");
/// assert!(metadata.required);
/// assert!(!metadata.computed);
/// # Ok(())
/// # }
/// ```
    pub fn from_schema_value(value: &serde_json::Value) -> Result<Self, AttributeMetadataError> {
        let required = value
            .get("required")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);
        let computed = value
            .get("computed")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);
        let optional = value
            .get("optional")
            .and_then(|v| v.as_bool())
            .unwrap_or(false);

        let attr_type = value
            .get("type")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown")
            .to_string();

        let description = value
            .get("description")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let description_kind = value
            .get("description_kind")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let sensitive = value.get("sensitive").and_then(|v| v.as_bool());

        Ok(AttributeMetadata {
            required,
            computed,
            optional,
            attr_type,
            description,
            description_kind,
            sensitive,
        })
    }

    /// Calculate a relevance score for ID inference
    /// Higher scores indicate better candidates for resource identification
    pub fn calculate_base_score(&self) -> f64 {
        let mut score = 30.0; // Base score

        // Prefer required fields - they're essential to the resource
        if self.required {
            score += 15.0;
        }

        // Computed fields are often auto-generated IDs
        if self.computed {
            score += 10.0;
        }

        // String types are generally better for human-readable IDs
        if self.attr_type == "string" {
            score += 5.0;
        }

        // Bonus for fields that mention identification in description
        if let Some(ref desc) = self.description {
            let desc_lower = desc.to_lowercase();
            if desc_lower.contains("identifier") || desc_lower.contains("unique") {
                score += 8.0;
            }
            if desc_lower.contains("name") || desc_lower.contains("id") {
                score += 5.0;
            }
        }

        score
    }

    /// Check if this attribute looks like it could be an ID field
    pub fn is_potential_id(&self) -> bool {
        // Must be a string type for most ID use cases
        if self.attr_type != "string" {
            return false;
        }

        // Either required or computed (not just optional metadata)
        self.required || self.computed
    }
}

/// Type alias for a map of attribute names to their metadata for a specific resource type
/// 
/// This type represents a complete mapping of all attributes for a terraform resource type,
/// where each attribute name is associated with its parsed metadata. It's commonly used
/// to store the complete schema information for a resource type.
/// 
/// # Key Usage
/// - Storing parsed schema information for resource types
/// - Passing complete attribute sets to scoring strategies
/// - Caching schema metadata for performance optimization
/// 
/// # Structure
/// - **Key**: Attribute name (e.g., "id", "name", "instance_id")
/// - **Value**: Complete AttributeMetadata for that attribute
/// 
/// # Examples
/// ```no_run
/// use terragrunt_import_from_plan::schema::metadata::{ResourceAttributeMap, AttributeMetadata};
/// use std::collections::HashMap;
/// 
/// let mut resource_attrs = ResourceAttributeMap::new();
/// resource_attrs.insert("id".to_string(), AttributeMetadata {
///     required: false,
///     computed: true,
///     optional: false,
///     attr_type: "string".to_string(),
///     description: Some("Resource ID".to_string()),
///     description_kind: None,
///     sensitive: None,
/// });
/// 
/// // Use with scoring strategies
/// for (attr_name, metadata) in &resource_attrs {
///     let score = metadata.calculate_base_score();
///     println!("{}: {}", attr_name, score);
/// }
/// ```
pub type ResourceAttributeMap = HashMap<String, AttributeMetadata>;

/// Errors that can occur when parsing terraform attribute metadata
/// 
/// This enum defines the various error conditions that can occur during the parsing
/// and processing of terraform provider schema data. Each variant provides specific
/// context about what went wrong during the parsing process.
/// 
/// # Error Categories
/// - **Missing Data**: Required schema fields are absent
/// - **Type Mismatches**: Schema values don't match expected types
/// - **Parse Failures**: General parsing errors with descriptive messages
/// 
/// # Usage
/// These errors are returned by `AttributeMetadata::from_schema_value()` and other
/// parsing functions to provide detailed feedback about schema processing failures.
#[derive(Debug, thiserror::Error)]
pub enum AttributeMetadataError {
    /// A required field is missing from the schema definition
    /// 
    /// This error occurs when the terraform schema is missing a field that is
    /// essential for proper attribute metadata extraction.
    #[error("Missing required field in schema: {field}")]
    MissingField { field: String },

    #[error("Invalid type for field {field}: expected {expected}, got {actual}")]
    InvalidType {
        /// Name of the field with the wrong type
        field: String,
        /// Expected type for the field
        expected: String,
        /// Actual type found in the schema
        actual: String,
    },

    #[error("Schema parsing error: {message}")]
    ParseError { 
        /// Descriptive error message explaining what went wrong
        message: String 
    },
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_attribute_metadata_from_schema_value() {
        let schema = json!({
            "type": "string",
            "description": "The unique identifier for the resource",
            "description_kind": "plain",
            "required": true,
            "computed": false
        });

        let metadata = AttributeMetadata::from_schema_value(&schema).unwrap();
        assert_eq!(metadata.attr_type, "string");
        assert!(metadata.required);
        assert!(!metadata.computed);
        assert_eq!(
            metadata.description,
            Some("The unique identifier for the resource".to_string())
        );
    }

    #[test]
    fn test_calculated_base_score() {
        let metadata = AttributeMetadata {
            required: true,
            computed: false,
            optional: false,
            attr_type: "string".to_string(),
            description: Some("The unique identifier for this resource".to_string()),
            description_kind: Some("plain".to_string()),
            sensitive: None,
        };

        let score = metadata.calculate_base_score();
        // Base(30) + Required(15) + String(5) + ID in description(5) = 55
        assert!(score >= 55.0);
    }

    #[test]
    fn test_is_potential_id() {
        let good_candidate = AttributeMetadata {
            required: true,
            computed: false,
            optional: false,
            attr_type: "string".to_string(),
            description: None,
            description_kind: None,
            sensitive: None,
        };
        assert!(good_candidate.is_potential_id());

        let bad_candidate = AttributeMetadata {
            required: false,
            computed: false,
            optional: true,
            attr_type: "bool".to_string(),
            description: None,
            description_kind: None,
            sensitive: None,
        };
        assert!(!bad_candidate.is_potential_id());
    }
}
