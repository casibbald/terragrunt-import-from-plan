//! # Schema Metadata Processing Module
//! 
//! This module provides functionality for extracting and processing metadata from terraform
//! provider schemas. It converts raw JSON schema definitions into structured metadata that
//! can be used for intelligent ID scoring and resource analysis.
//! 
//! ## Key Components
//! 
//! - **AttributeMetadata**: Rich metadata about terraform resource attributes
//! - **Schema Parsing**: Extract metadata from terraform provider schema JSON
//! - **ID Scoring Integration**: Calculate base scores for ID candidate selection
//! - **Validation Logic**: Determine which attributes could be viable ID fields
//! 
//! ## Usage Patterns
//! 
//! 1. Parse schema JSON using `AttributeMetadata::from_schema_value()`
//! 2. Use metadata for intelligent scoring in provider strategies
//! 3. Validate ID candidates using `is_potential_id()`
//! 4. Calculate base scores using `calculate_base_score()`
//! 
//! ## Integration
//! 
//! This module integrates closely with the scoring strategies to provide schema-driven
//! intelligence for ID inference, replacing hardcoded rules with dynamic analysis.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Rich metadata about a terraform resource attribute extracted from provider schema
/// 
/// This structure contains comprehensive information about a terraform resource attribute,
/// including its constraints, type information, and descriptive metadata. It enables
/// intelligent analysis for ID candidate selection and resource understanding.
/// 
/// # Key Features
/// - **Constraint Analysis**: Required, computed, optional field detection
/// - **Type Information**: Attribute type classification (string, number, bool, etc.)
/// - **Documentation**: Human-readable descriptions and formatting information
/// - **Security**: Sensitive field detection for proper handling
/// - **ID Scoring**: Built-in scoring logic for ID candidate evaluation
/// 
/// # Fields
/// - `required`: Indicates if the attribute is required when creating the resource
/// - `computed`: Indicates if the attribute is auto-generated by the provider
/// - `optional`: Indicates if the attribute can be omitted
/// - `attr_type`: The terraform type of the attribute (string, number, bool, etc.)
/// - `description`: Human-readable description of the attribute's purpose
/// - `description_kind`: Format of the description (plain text, markdown, etc.)
/// - `sensitive`: Whether the attribute contains sensitive information
/// 
/// # Examples
/// ```no_run
/// use terragrunt_import_from_plan::schema::metadata::AttributeMetadata;
/// use serde_json::json;
/// 
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let schema = json!({
///     "type": "string",
///     "description": "The unique identifier for the resource",
///     "required": true,
///     "computed": false
/// });
/// 
/// let metadata = AttributeMetadata::from_schema_value(&schema)?;
/// println!("Base score: {}", metadata.calculate_base_score());
/// println!("Potential ID: {}", metadata.is_potential_id());
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AttributeMetadata {
    /// Whether this attribute is required when creating the resource
    /// 
    /// Required attributes are essential for resource creation and are often
    /// key identifying information. They receive higher ID candidate scores.
    pub required: bool,
    
    /// Whether this attribute is computed (auto-generated) by the provider
    /// 
    /// Computed attributes are generated by the cloud provider and often
    /// contain auto-generated IDs, ARNs, or other identifying information.
    pub computed: bool,
    
    /// Whether this attribute is optional (can be omitted)
    /// 
    /// Optional attributes can be provided but aren't required. They may
    /// still be useful for identification in some cases.
    pub optional: bool,
    
    /// The terraform type of the attribute
    /// 
    /// Common types include: "string", "number", "bool", "list", "map", "set".
    /// String types are generally preferred for human-readable identifiers.
    pub attr_type: String,
    
    /// Human-readable description of the attribute's purpose
    /// 
    /// This text often contains valuable hints about whether an attribute
    /// is suitable for use as an identifier. Descriptions mentioning "unique",
    /// "identifier", "name", or "id" receive scoring bonuses.
    pub description: Option<String>,
    
    /// Format specification for the description text
    /// 
    /// Indicates whether the description is plain text, markdown, or another format.
    /// This affects how the description should be processed and displayed.
    pub description_kind: Option<String>,
    
    /// Whether this attribute contains sensitive information
    /// 
    /// Sensitive attributes contain secrets, passwords, or other confidential
    /// data that should be handled with special care and likely aren't suitable
    /// as public identifiers.
    pub sensitive: Option<bool>,
}

impl AttributeMetadata {
    /// Creates a new AttributeMetadata instance from terraform schema JSON
    /// 
    /// This method parses the raw JSON schema definition for a terraform attribute
    /// and extracts all relevant metadata into a structured format. It handles
    /// missing fields gracefully by providing sensible defaults.
    /// 
    /// # Arguments
    /// * `value` - JSON value containing the terraform schema definition for an attribute
    /// 
    /// # Returns
    /// Result containing the parsed AttributeMetadata or an error if parsing fails
    /// 
    /// # Schema Format
    /// The expected JSON schema follows terraform's provider schema format:
    /// ```json
    /// {
    ///   "type": "string",
    ///   "description": "Human readable description",
    ///   "required": true,
    ///   "computed": false,
    ///   "optional": false,
    ///   "sensitive": false
    /// }
    /// ```
    /// 
    /// # Error Handling
    /// - Missing fields are handled with sensible defaults (false for booleans, "unknown" for type)
    /// - Invalid JSON structure returns AttributeMetadataError
    /// - Type mismatches are handled gracefully where possible
    /// 
    /// # Examples
/// ```no_run
/// use terragrunt_import_from_plan::schema::metadata::AttributeMetadata;
/// use serde_json::json;
/// 
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// let schema = json!({
///     "type": "string",
///     "description": "The resource name",
///     "required": true,
///     "computed": false
/// });
/// 
/// let metadata = AttributeMetadata::from_schema_value(&schema)?;
/// assert_eq!(metadata.attr_type, "string");
/// assert!(metadata.required);
/// assert!(!metadata.computed);
/// # Ok(())
/// # }
/// ```
    pub fn from_schema_value(value: &serde_json::Value) -> Result<Self, AttributeMetadataError> {
        let required = value.get("required").and_then(|v| v.as_bool()).unwrap_or(false);
        let computed = value.get("computed").and_then(|v| v.as_bool()).unwrap_or(false);
        let optional = value.get("optional").and_then(|v| v.as_bool()).unwrap_or(false);
        
        let attr_type = value
            .get("type")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown")
            .to_string();
            
        let description = value
            .get("description")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
            
        let description_kind = value
            .get("description_kind")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
            
        let sensitive = value.get("sensitive").and_then(|v| v.as_bool());
        
        Ok(AttributeMetadata {
            required,
            computed,
            optional,
            attr_type,
            description,
            description_kind,
            sensitive,
        })
    }
    
    /// Calculates a base relevance score for ID inference
    /// 
    /// This method implements intelligent scoring logic that analyzes the attribute's
    /// metadata to determine how likely it is to be useful as a resource identifier.
    /// The score is used as a foundation by provider-specific strategies.
    /// 
    /// # Returns
    /// Floating-point score from 30.0 to ~65.0 based on attribute characteristics
    /// 
    /// # Scoring Logic
    /// - **Base Score**: 30.0 (all attributes start here)
    /// - **Required Fields**: +15.0 (essential to resource creation)
    /// - **Computed Fields**: +10.0 (often auto-generated IDs)
    /// - **String Type**: +5.0 (preferred for human-readable IDs)
    /// - **Description Analysis**: +5.0 to +8.0 for ID-related keywords
    /// 
    /// # Description Keywords
    /// The method analyzes the description text for these hints:
    /// - "unique" or "identifier": +8.0 bonus
    /// - "name" or "id": +5.0 bonus
    /// 
    /// # Examples
    /// ```no_run
    /// use terragrunt_import_from_plan::schema::metadata::AttributeMetadata;
    /// 
    /// // High-scoring ID field
    /// let id_field = AttributeMetadata {
///     required: true,          // +15.0
///     computed: true,          // +10.0
///     optional: false,
///     attr_type: "string".to_string(),  // +5.0
///     description: Some("Unique identifier".to_string()), // +8.0
///     description_kind: None,
///     sensitive: None,
/// };
    /// 
    /// let score = id_field.calculate_base_score();
    /// // Score = 30.0 + 15.0 + 10.0 + 5.0 + 8.0 = 68.0
    /// assert!(score >= 68.0);
    /// ```
    pub fn calculate_base_score(&self) -> f64 {
        let mut score = 30.0; // Base score
        
        // Prefer required fields - they're essential to the resource
        if self.required {
            score += 15.0;
        }
        
        // Computed fields are often auto-generated IDs
        if self.computed {
            score += 10.0;
        }
        
        // String types are generally better for human-readable IDs
        if self.attr_type == "string" {
            score += 5.0;
        }
        
        // Bonus for fields that mention identification in description
        if let Some(ref desc) = self.description {
            let desc_lower = desc.to_lowercase();
            if desc_lower.contains("identifier") || desc_lower.contains("unique") {
                score += 8.0;
            }
            if desc_lower.contains("name") || desc_lower.contains("id") {
                score += 5.0;
            }
        }
        
        score
    }
    
    /// Determines if this attribute could potentially be used as an ID field
    /// 
    /// This method applies filtering logic to determine whether an attribute has
    /// the basic characteristics needed to serve as a resource identifier. It's
    /// used to pre-filter attributes before more detailed scoring analysis.
    /// 
    /// # Returns
    /// `true` if the attribute meets basic ID candidate criteria, `false` otherwise
    /// 
    /// # Filtering Criteria
    /// An attribute is considered a potential ID if it meets ALL these conditions:
    /// 1. **Type Requirement**: Must be a "string" type (human-readable)
    /// 2. **Importance**: Must be either required OR computed (not just optional metadata)
    /// 
    /// # Rationale
    /// - **String Type**: Non-string types (numbers, booleans, etc.) are rarely useful as identifiers
    /// - **Required/Computed**: Purely optional fields are usually metadata, not core identifiers
    /// 
    /// # Examples
    /// ```no_run
    /// use terragrunt_import_from_plan::schema::metadata::AttributeMetadata;
    /// 
    /// // Good ID candidate
/// let good_candidate = AttributeMetadata {
///     required: true,
///     computed: false,
///     optional: false,
///     attr_type: "string".to_string(),
///     description: None,
///     description_kind: None,
///     sensitive: None,
/// };
/// assert!(good_candidate.is_potential_id());
/// 
/// // Poor ID candidate (wrong type)
/// let poor_candidate = AttributeMetadata {
///     required: true,
///     computed: false,
///     optional: false,
///     attr_type: "bool".to_string(),  // Not a string
///     description: None,
///     description_kind: None,
///     sensitive: None,
/// };
/// assert!(!poor_candidate.is_potential_id());
/// 
/// // Poor ID candidate (not important)
/// let optional_field = AttributeMetadata {
///     required: false,     // Not required
///     computed: false,     // Not computed
///     optional: true,
///     attr_type: "string".to_string(),
///     description: None,
///     description_kind: None,
///     sensitive: None,
/// };
/// assert!(!optional_field.is_potential_id());
    /// ```
    pub fn is_potential_id(&self) -> bool {
        // Must be a string type for most ID use cases
        if self.attr_type != "string" {
            return false;
        }
        
        // Either required or computed (not just optional metadata)
        self.required || self.computed
    }
}

/// Type alias for a map of attribute names to their metadata for a specific resource type
/// 
/// This type represents a complete mapping of all attributes for a terraform resource type,
/// where each attribute name is associated with its parsed metadata. It's commonly used
/// to store the complete schema information for a resource type.
/// 
/// # Key Usage
/// - Storing parsed schema information for resource types
/// - Passing complete attribute sets to scoring strategies
/// - Caching schema metadata for performance optimization
/// 
/// # Structure
/// - **Key**: Attribute name (e.g., "id", "name", "instance_id")
/// - **Value**: Complete AttributeMetadata for that attribute
/// 
/// # Examples
/// ```no_run
/// use terragrunt_import_from_plan::schema::metadata::{ResourceAttributeMap, AttributeMetadata};
/// use std::collections::HashMap;
/// 
/// let mut resource_attrs = ResourceAttributeMap::new();
/// resource_attrs.insert("id".to_string(), AttributeMetadata {
///     required: false,
///     computed: true,
///     optional: false,
///     attr_type: "string".to_string(),
///     description: Some("Resource ID".to_string()),
///     description_kind: None,
///     sensitive: None,
/// });
/// 
/// // Use with scoring strategies
/// for (attr_name, metadata) in &resource_attrs {
///     let score = metadata.calculate_base_score();
///     println!("{}: {}", attr_name, score);
/// }
/// ```
pub type ResourceAttributeMap = HashMap<String, AttributeMetadata>;

/// Errors that can occur when parsing terraform attribute metadata
/// 
/// This enum defines the various error conditions that can occur during the parsing
/// and processing of terraform provider schema data. Each variant provides specific
/// context about what went wrong during the parsing process.
/// 
/// # Error Categories
/// - **Missing Data**: Required schema fields are absent
/// - **Type Mismatches**: Schema values don't match expected types
/// - **Parse Failures**: General parsing errors with descriptive messages
/// 
/// # Usage
/// These errors are returned by `AttributeMetadata::from_schema_value()` and other
/// parsing functions to provide detailed feedback about schema processing failures.
#[derive(Debug, thiserror::Error)]
pub enum AttributeMetadataError {
    /// A required field is missing from the schema definition
    /// 
    /// This error occurs when the terraform schema is missing a field that is
    /// essential for proper attribute metadata extraction.
    #[error("Missing required field in schema: {field}")]
    MissingField { 
        /// Name of the missing field
        field: String 
    },
    
    /// A schema field has an unexpected type
    /// 
    /// This error occurs when a schema field exists but contains a value of the
    /// wrong type (e.g., string instead of boolean).
    #[error("Invalid type for field {field}: expected {expected}, got {actual}")]
    InvalidType {
        /// Name of the field with the wrong type
        field: String,
        /// Expected type for the field
        expected: String,
        /// Actual type found in the schema
        actual: String,
    },
    
    /// General schema parsing error with a descriptive message
    /// 
    /// This error covers other parsing failures that don't fit the more specific
    /// error categories above.
    #[error("Schema parsing error: {message}")]
    ParseError { 
        /// Descriptive error message explaining what went wrong
        message: String 
    },
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_attribute_metadata_from_schema_value() {
        let schema = json!({
            "type": "string",
            "description": "The unique identifier for the resource",
            "description_kind": "plain",
            "required": true,
            "computed": false
        });

        let metadata = AttributeMetadata::from_schema_value(&schema).unwrap();
        assert_eq!(metadata.attr_type, "string");
        assert!(metadata.required);
        assert!(!metadata.computed);
        assert_eq!(metadata.description, Some("The unique identifier for the resource".to_string()));
    }

    #[test]
    fn test_calculated_base_score() {
        let metadata = AttributeMetadata {
            required: true,
            computed: false,
            optional: false,
            attr_type: "string".to_string(),
            description: Some("The unique identifier for this resource".to_string()),
            description_kind: Some("plain".to_string()),
            sensitive: None,
        };

        let score = metadata.calculate_base_score();
        // Base(30) + Required(15) + String(5) + ID in description(5) = 55
        assert!(score >= 55.0);
    }

    #[test]
    fn test_is_potential_id() {
        let good_candidate = AttributeMetadata {
            required: true,
            computed: false,
            optional: false,
            attr_type: "string".to_string(),
            description: None,
            description_kind: None,
            sensitive: None,
        };
        assert!(good_candidate.is_potential_id());

        let bad_candidate = AttributeMetadata {
            required: false,
            computed: false,
            optional: true,
            attr_type: "bool".to_string(),
            description: None,
            description_kind: None,
            sensitive: None,
        };
        assert!(!bad_candidate.is_potential_id());
    }
} 